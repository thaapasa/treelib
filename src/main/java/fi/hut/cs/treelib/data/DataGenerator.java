package fi.hut.cs.treelib.data;

import java.util.Iterator;
import java.util.NavigableSet;
import java.util.Random;
import java.util.TreeSet;

import fi.hut.cs.treelib.Key;
import fi.hut.cs.treelib.KeyRange;
import fi.hut.cs.treelib.PageValue;
import fi.hut.cs.treelib.action.Action;
import fi.hut.cs.treelib.action.CommitTransactionAction;
import fi.hut.cs.treelib.action.DeleteAction;
import fi.hut.cs.treelib.action.InsertAction;
import fi.hut.cs.treelib.internal.KeyRangeImpl;
import fi.tuska.util.iterator.Iterables;

public class DataGenerator<K extends Key<K>> implements Iterator<K>, Iterable<K>, Generator<K> {

    private final K minLimit;
    private final K maxLimit;
    private final K bounds;
    private final Long limit;
    private final Random random = new Random();
    private long pos;

    private final NavigableSet<K> insertedKeys = new TreeSet<K>();
    private final NavigableSet<K> allInsertedKeys = new TreeSet<K>();

    public DataGenerator(K bounds, K minLimit, K maxLimit, long amount) {
        this.bounds = bounds;
        this.minLimit = minLimit;
        this.maxLimit = maxLimit;
        this.limit = new Long(amount);
        this.pos = 0;
    }

    public DataGenerator(K bounds, K minLimit, K maxLimit) {
        this.bounds = bounds;
        this.minLimit = minLimit;
        this.maxLimit = maxLimit;
        // No limit
        this.limit = null;
        this.pos = 0;
    }

    public int getAliveKeyCount() {
        return insertedKeys.size();
    }

    public int getAllInsertedKeyCount() {
        return allInsertedKeys.size();
    }

    public K getRangeSize() {
        return maxLimit.subtract(minLimit);
    }

    public K getPrototype() {
        return bounds;
    }

    public <V extends PageValue<?>> void applyActions(Iterator<Action<K, V>> actions) {
        for (Action<K, ?> action : Iterables.get(actions)) {
            if (action instanceof InsertAction<?, ?>) {
                insertedKeys.add(action.getKey());
            } else if (action instanceof DeleteAction<?, ?>) {
                insertedKeys.remove(action.getKey());
            } else if (action instanceof CommitTransactionAction<?, ?>) {
                commit();
            }
        }
    }

    @Override
    public boolean hasNext() {
        return limit == null || pos < limit.longValue();
    }

    @Override
    public K generate() {
        return bounds.random(minLimit, maxLimit, random);
    }

    @Override
    public K next() {
        pos++;
        return generate();
    }

    public KeyRange<K> getRange(double size) {
        K rangeSize = getRangeSize().multiply(size);
        K min = next().subtract(rangeSize.multiply(0.5));
        K max = min.add(rangeSize);
        return new KeyRangeImpl<K>(min, max);
    }

    /**
     * Only returns keys that have been previously returned by a call to
     * insert.
     * 
     * @return a key for deletion; or null, if there are no keys to delete
     */
    public K delete() {
        K toDelete = modify();
        if (toDelete == null)
            return null;
        boolean success = insertedKeys.remove(toDelete);
        assert success;
        return toDelete;
    }

    /**
     * Only returns keys that have been previously returned by a call to
     * insert.
     * 
     * @return a key for modification; or null, if there are no keys to modify
     */
    public K modify() {
        if (insertedKeys.size() < 1) {
            return null;
        }
        K toModify = null;
        while (toModify == null) {
            K candidate = generate();
            toModify = insertedKeys.lower(candidate);
            if (toModify == null)
                toModify = insertedKeys.higher(candidate);

        }
        return toModify;
    }

    public void commit() {
        allInsertedKeys.addAll(insertedKeys);
    }

    /**
     * Only returns keys that have been previously returned by a call to
     * insert.
     * 
     * @return a key for querying; or null, if there are no keys to query
     */
    public K query() {
        return modify();
    }

    /**
     * Tracks keys, so that a call to delete only returns keys that have been
     * generated by calls to this method. Does not return keys that have
     * already been generated by calls to insert (unless they have been
     * deleted by a call to delete).
     * 
     * @return a key for insertion
     */
    public K insert() {
        K key = generate();
        while (insertedKeys.contains(key)) {
            key = generate();
        }
        insertedKeys.add(key);
        return key;
    }

    @Override
    public void remove() {
        throw new UnsupportedOperationException("remove() not supported");
    }

    @Override
    public Iterator<K> iterator() {
        return this;
    }

}
